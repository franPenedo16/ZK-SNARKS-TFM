{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17187884284671724965,"abi":{"parameters":[{"name":"dni","type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":64},{"kind":"string","length":1}]},"visibility":"private"},{"name":"pass","type":{"kind":"field"},"visibility":"private"},{"name":"solution","type":{"kind":"array","length":9,"type":{"kind":"array","length":9,"type":{"kind":"integer","sign":"unsigned","width":32}}},"visibility":"private"},{"name":"problem","type":{"kind":"array","length":9,"type":{"kind":"array","length":9,"type":{"kind":"integer","sign":"unsigned","width":32}}},"visibility":"public"}],"return_type":{"abi_type":{"kind":"struct","path":"OutStruct","fields":[{"name":"dni_letter","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"password_hash","type":{"kind":"field"}},{"name":"problem","type":{"kind":"array","length":9,"type":{"kind":"array","length":9,"type":{"kind":"integer","sign":"unsigned","width":32}}}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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3TtC91LQvQV0rT1de07XYtO1yXStLl27StdyPocvXetH177RtWB0bRRdK0TXztC1JHRtBV1rQHvvtBdNe7O0V0l7d7SX9Q6+tNfxHr5UC6faMNVKqXZItTSqLVGthWoPtBantSmt1WjtQrk85baU61HuQ7kAxUaKFeQ7yZdkc51dgwt9akbPHps/tNPDRtPnioaj6PP+qMX2eOKK0c1tV2nartG0Xadpu0HTdpOm7RZN26xG25OnPfvIlUdHaXPb7Zq2OzVtd2va7tW03a9pm61pe1DT9rCm7VENl8c15z2pOe9pzXnPas57XnPePzXn/Utz3sua817VnPe65rw3Nee9rTnvXc15/9ac94Gm7SNN2yeats80bV9o2r7StH2j0e87TdsPmrafNG2/aNp+07T9oWn7S9PWodP/bqs32lpx6aQ5r4vmvK6a87ppzuuuOW9BzXkLac5bWHNeH815i2rOW0xz3uKa85bQnLeU5rylNW3LaNqW1bQtr2lbUdO2kqZtZY1+wzRtStNma9pcTZuvaQs1batq2kZo2lbXcBmlOW9NzXmjNeeN0Zw3VnPeuprzxmvOm6A5bwPNeRtqzpusOW8TzXmbac7bQnPeVpq2bTRtkaYt0bRlmrbtNG07aPTbSdO2i6ZtN03bHpq2vTRtUzRt+2rapmraDtBwmaY572DNeYdqzjtcc94RmvOO0px3jOa84zTnnaA57yTNeadozjtVc95MzXlnaM47S9N2jqbtPE3bBZq2izRtl2jaLtPod4Wm7SpN2zWatus0bTdo2m7StN2iaZulabtdw+VOzXl3a867V3Pe/ZrzZmvOe1Bz3sOa8x7VnPe45rwnNec9rTnvWc15z2vO+6fmvH9p2l7WtL2qaXtd0/ampu1tTdu7Gv3+rWn7QNP2kabtE03bZ5q2LzRtX2navtG0fafh8oPmvJ805/2iOe83zXl/aM77S3Neh87/+7x65/99XifNeV0053XVnNdNc153zXkLas5bSNO2sKatj6ZtUU3bYpq2xTVtS2j0W0rTtrSmbRlN27KatuU1bStq2lbStK2saRum4aI059ma81zNeb7mvFBz3qqa80Zozltdc94ozXlras4brTlvjOa8sZrz1tWcN17TNkHTtoGmbUNN22RN2yaats00+m2hadtK07aNpi3StCWatkzTtp2mbQdN204aLrtozttNc94emvP20pw3RXPevprzpmrOO0Bz3jTNeQdrzjtUc97hmvOO0Jx3lOa8YzRtx2naTtC0naRpO0XTdqqmbaZGvzM0bWdp2s7RtJ2nabtA03aRpu0STdtlmrYrNFyu0px3jea86zTn3aA57ybNebdozpulOe92zXl3as67W3PevZrz7tecN1tz3lua897RtL2naXtf0/ahpu1jTdunmrbPNfp9qWn7WtP2rabte03bj5q2nzVtv2r0+13T9qembc4FNv+jraZp66hp66xpm0/TNr+mbQFNWw9NW09NWy9NW29N2yKNtlZj1FfT1k/T1l/TtqSmbYCmbaCmbZBGv+U0bSto2gZr2oZo2oZq2kxNm6VpczRtnqYt0LStomkbrmlbTdM2UjNGa2ja1tK0ra1pW0fTNk7Ttp6mbX2NfhM1bZM0bRtp2jbWtG2qadtc07alpm1rTdu2mrZY05Zq2nJN2/aath01Y7Szpm1XTdvumrY9NW17a9r20bTtp9Fvf03bgZq2gzRth2jaDtO0Tde0HalpO1rTdqym7XhN24matpM1bTM0badpxuh0TduZmrazNW3natrO17RdqGm7WKPfpZq2yzVtV2rarta0Xatpu17TdqOm7WZN262atts0bXdo2u7StN2jabtPM0YPaNr+oWl7SNP2iKbtMU3bE5q2pzT6PaNpe07T9oKm7UVN20uatlc0ba9p2t7QtL2laXtH0/aepu19TduHmraPNWP0qabtc03bl5q2rzVt32ravte0/ajR72dN26+att81bX9q2ubcXPE/2mqato6ats6atvk0bfNr2hbQtPXQtPXUtPVqtLUao96atkU0bX01bf00bf01bUtq2gZo9BuoaRukaVtO07aCpm2wpm2Ipm2ops3UtFmaNkfT5mnaAk3bKpq24ZoxWk3TNlLTtoambS1N29qatnU0beM0+q2naVtf0zZR0zZJ07aRpm1jTdtemrYpmrZ9NW1TNW0HaNqmadoO1rQdqmk7XNN2hKbtKE3bMZq24zRtJ2jaTtK0naJpO1XTNlPTdoam7SyNzZ+jOe88TdsFGpkXac67RNN2mUbmFZrzrtK0XaNpu07z927QtN2kkXmLpm2Wpu12Tdudmr7crWm7VyPzfk3bbE3bg5q2hzV9eVTT9rhG5pOatqc1bc9q2p7X9OWfmrZ/aWS+rGl7VdP2uqbtTU1f3ta0vauR+W9N2weato80bZ9o+vKZpu0LjcyvNG3faNq+07T9oOnLT5q2XzQyf9O0/aFp+0vT1qHr/+5LXdPWqev/ltlF09ZV09ZN09Zd05cFNW0LaWQurGnro2lbVPP3FtOct7imbQmNzKU05y2taVtGI3NZzXnLa9pW1LStpPl7K2vahmlkKk2brWlzNW2+pi+hpm1VjcwRmrbVNW2jNG1ravoyWtM2RiNzrKZtXU3beE3bBE1fNtC0baiROVnTtommbTNN2xaavmyladtGIzPStCWatkzTtp2mLzto2nbSyNxF07abpm0PTdtemr5M0bTtq5E5VdN2gKZtmqbtYE1fDtW0Ha6ReYSm7ShN2zGatuM0fTlB03aSRuYpmrZTNW0zNX/vDM15Z2naztHIPE9z3gWatos0Mi/5H+fNfSRGIy0yGr8255k39KHn49CzcUY2/m2272PNld9NRv7cyzbafOZv+u9u87TN1b9ji/M6/I9/1+b5qfvdeY83H+veom2uzIUbP5v7O1ePrvP87NMkl5Hl3HRjznONBOS3HKs+Tf/dex49m3mPZOrDXHn1xs9Oxt8/tXna5v7uvHOmA3//1Lx9qbf4W3M/c22md9OxuTz/P3uWSw5H9AcA","debug_symbols":"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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"use std::hash::poseidon;\n\nstruct OutStruct {\n    dni_letter: u8,\n    password_hash: Field,\n    problem: [[u32;9];9],\n}\n\nfn main(dni : (u64, str<1>), pass: Field, solution: [[u32;9];9], problem: pub [[u32;9];9]) -> pub OutStruct{\n\n    let list_letters:[u8] = [84, 82, 87, 65, 71, 77, 89, 70, 80, 68, 88, 66, 78, 74, 90, 83, 81, 86, 72, 76, 67, 75, 69];\n    let index_array: [u32;9] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let index_boxes: [u32;3] = [0, 3, 6];\n    let acc: u32 = 0;\n    let acc_1: u32 = 1;\n\n    // DNI VALIDATE -----------------------\n\n        // validate prohibited dni numbers\n    assert(dni.0 > 1 & dni.0 < 99999999);\n\n        // Validate letter of dni \n    let supose_letter = dni.1.as_bytes();\n\n    let calculate_letter = dni.0 % 23;\n\n    assert(list_letters[calculate_letter] == supose_letter[0]);\n    \n\n    // PASS VALIDATE -----------------------------------------\n\n    let hash = poseidon::bn254::hash_1([pass]);\n\n    // GAME VALIDATE -------------------------------------------\n\n        // check consistency problen & solution\n    let check_consistency = index_array.all(|index| {\n        let row_consistency = index_array.all(|kindex| {\n            (solution[index][kindex] == problem[index][kindex]) | (problem[index][kindex] == 0)\n        });\n        row_consistency\n    });\n\n    assert(check_consistency);\n\n        // check rows if are OK\n    let check_rows = solution.all(|sol| {\n        (sol.fold(acc, |a, b| a + b) == 45) &\n        (sol.fold(acc_1, |a, b| a * b) == 362880) &\n        (sol.fold(acc, |a, b| (b * b) + a) == 285)\n    });\n\n    assert(check_rows);\n\n\n        // check cols if are OK\n    let check_cols = index_array.all(|index| {\n        let col = solution.map(|sol| sol[index]);\n        (col.fold(acc, |a, b| a + b) == 45) &\n        (col.fold(acc_1, |a, b| a * b) == 362880) &\n        (col.fold(acc, |a, b| (b * b) + a) == 285)\n    });\n\n    assert(check_cols);\n\n\n        // check boxes if are OK\n    let check_boxes = index_boxes.all(|i|{\n\n        let row_boxes = solution.map(|sol| {\n            [sol[0 + i] + sol[1 + i] + sol[2 + i],\n             sol[0 + i] * sol[1 + i] * sol[2 + i],\n             sol[0 + i] * sol[0 + i] + sol[1 + i] * sol[1 + i] + sol[2 + i] * sol[2 + i]]\n        });\n\n        let check_row_box = index_boxes.all(|k|{\n            (row_boxes[0 + k][0] + row_boxes[1 + k][0] + row_boxes[2 + k][0] == 45) &\n            (row_boxes[0 + k][1] * row_boxes[1 + k][1] * row_boxes[2 + k][1] == 362880) &\n            (row_boxes[0 + k][2] + row_boxes[1 + k][2] + row_boxes[2 + k][2] == 285)\n        });\n\n        check_row_box\n    });\n\n    assert(check_boxes);\n\n\n    // OUTPUTS -------------------------------------------\n\n    OutStruct {\n        dni_letter: dni.1.as_bytes()[0],\n        password_hash: hash,\n        problem: problem\n    }\n\n}\n","path":"/run/media/fpenedo/T7 Shield/tfm/ZK-SNARKS-TFM/noir/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}